/* Code section */
%{

#include <stdlib.h>
#include <stdio.h>

#include "utils.h"

// Reference to the yylex function to quiet a compiler warning
// Reference to the line number generated by the scanner
int yylex();
extern int yylineno;
struct tree_decls *root;

void yyerror(char const *s)
{
    fprintf(stderr, "Error: syntax on line %d: %s\n", yylineno, s);
    exit(1);
}

%}

%code requires
{

#include "tree.h"

}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union
{
    int intval;
    double floatval;
    char *strval;
    char runeval;
    struct tree_idents *idents;
    struct tree_exps *exps;
    struct tree_decls *decls;
    struct tree_var_spec *var_decl;
    struct tree_stmts *stmts;
    struct tree_vars *vars;
    struct tree_type *type;
    struct tree_stmt *stmt;
    struct tree_exp *exp;
    struct tree_if ifstmt;
    struct tree_assign assign;
    struct tree_assignop assignop;
    struct tree_switch switchstmt;
    struct tree_cases *cases;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */
%token                  TOK_AND
%token                  TOK_ANDEQ
%token                  TOK_ANDNOT
%token                  TOK_ANDNOTEQ
%token                  TOK_APPEND
%token                  TOK_ASSIGN
%token                  TOK_BREAK
%token                  TOK_CAP
%token                  TOK_CASE
%token                  TOK_CONTINUE
%token                  TOK_DEC
%token                  TOK_DEFAULT
%token                  TOK_DIVEQ
%token                  TOK_ELSE
%token                  TOK_EQ
%token                  TOK_FALLTHROUGH
%token  <floatval>      TOK_FLOAT
%token                  TOK_FOR
%token                  TOK_FUNC
%token                  TOK_GEQ
%token  <strval>        TOK_IDENT
%token                  TOK_IF
%token                  TOK_INC
%token  <intval>        TOK_INT
%token                  TOK_LEN
%token                  TOK_LEQ
%token                  TOK_LSHIFT
%token                  TOK_LSHIFTEQ
%token                  TOK_MINUSEQ
%token                  TOK_NEQ
%token                  TOK_OR
%token                  TOK_OREQ
%token                  TOK_PACKAGE
%token                  TOK_PLUSEQ
%token                  TOK_PRINT
%token                  TOK_PRINTLN
%token                  TOK_REMEQ
%token                  TOK_RETURN
%token                  TOK_RSHIFT
%token                  TOK_RSHIFTEQ
%token  <runeval>       TOK_RUNE
%token  <strval>        TOK_STR
%token                  TOK_STRUCT
%token                  TOK_SWITCH
%token                  TOK_TIMESEQ
%token                  TOK_TYPE
%token                  TOK_VAR
%token                  TOK_XOREQ

%type   <decls>         program top_level_decls var_decl var_specs type_decl
                        type_specs func_decl;
%type   <var_decl>      var_spec;
%type   <idents>        idents;
%type   <exps>          exps;
%type   <stmts>         stmt stmts block var_decl_stmt var_specs_stmt
                        type_decl_stmt type_specs_stmt;
%type   <vars>          params;
%type   <type>          type;
%type   <stmt>          simplestmt;
%type   <exp>           exp;
%type   <vars>          field_decls;
%type   <ifstmt>        ifstmt;
%type   <assign>        assignment;
%type   <assignop>      op_assignment;
%type   <switchstmt>    switchstmt;
%type   <cases>         cases;

/* Precedence directives  resolve grammar  ambiguities by breaking  ties between
 * shift/reduce  operations. Tokens  are grouped  into precendence  levels, with
 * lower precedence coming first and then higher precedence in later directives.
 * Tokens specified in the same directive  have the same precedence. Ties at the
 * same  level   are  broken  using   either  %left  or  %right,   which  denote
 * left-associative and right-associative respectively.
 */
%left TOK_OR 
%left TOK_AND 
%left TOK_EQ TOK_NEQ '<' TOK_LEQ '>' TOK_GEQ
%left '+' '-' '|' '^'
%left '*' '/' '%' TOK_LSHIFT TOK_RSHIFT '&' TOK_ANDNOT 
%left UNARY
%left '.'
%nonassoc '(' '['

/* Start token (by default if this is missing it takes the first production */
%start program
/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules
 * with the same LHS may be joined together and separated with a pipe.
 */
%glr-parser
%expect 1

%%

program:        package_decl ';' top_level_decls
                {
                    root = $3;
                }
        ;

package_decl:   TOK_PACKAGE TOK_IDENT
                {
                    if(strcmp($2, "_") == 0)
                    {
                        fprintf(stderr, "Error: package name may not be blank i\
dentifier");
                        exit(1);
                    }
                    free($2);
                }
        ;

top_level_decls:
                {
                    $$ = NULL;
                }
        |       var_decl ';' top_level_decls
                {
                    $$ = $1;
                    struct tree_decls *c = $$;
                    while(c->next)
                        c = c->next;
                    c->next = $3;
                }
        |       type_decl ';' top_level_decls
                {
                    $$ = $1;
                    struct tree_decls *c = $$;
                    while(c->next)
                        c = c->next;
                    c->next = $3;
                }
        |       func_decl ';' top_level_decls
                {
                    $$ = $1;
                    $$->next = $3;
                }
        ;

var_decl:       TOK_VAR var_spec
                {
                    $$ = emalloc(sizeof(struct tree_decls));
                    $$->kind = tree_decls_kind_var_decl;
                    $$->var_spec = $2;
                    $$->next = NULL;
                }
        |       TOK_VAR '(' var_specs ')'
                {
                    $$ = $3;
                }
        ;

var_specs:
                {
                    $$ = NULL;
                }
        |       var_spec ';' var_specs
                {
                    $$ = emalloc(sizeof(struct tree_decls));
                    $$->kind = tree_decls_kind_var_decl;
                    $$->var_spec = $1;
                    $$->next = $3;
                }
        ;

var_decl_stmt:  TOK_VAR var_spec
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_var_decl;
                    $$->stmt.var_spec = $2;
                    $$->next = NULL;
                }
        |       TOK_VAR '(' var_specs_stmt ')'
                {
                    $$ = $3;
                }
        ;

var_specs_stmt:
                {
                    $$ = NULL;
                }
        |       var_spec ';' var_specs_stmt
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_var_decl;
                    $$->stmt.var_spec = $1;
                    $$->next = $3;
                }
        ;

var_spec:       idents type
                {
                    $$ = emalloc(sizeof(struct tree_var_spec));
                    struct tree_var_spec *c = $$;
                    struct tree_idents *i = $1;
                    while(i->next)
                    {
                        c->name = i->ident;
                        c->type = $2;
                        c->val = NULL;
                        c = c->next = emalloc(sizeof(struct tree_var_spec));
                        i = i->next;
                    }
                    c->name = i->ident;
                    c->type = $2;
                    c->val = NULL;
                    c->next = NULL;
                    for(struct tree_idents *j = (i = $1)->next; j;
                        i = j, j = j->next)
                        free(i);
                    free(i);
                }
        |       idents '=' exps
                {
                    $$ = emalloc(sizeof(struct tree_var_spec));
                    struct tree_var_spec *c = $$;
                    struct tree_idents *i = $1;
                    struct tree_exps *j = $3;
                    while(i->next && j->next)
                    {
                        c->name = i->ident;
                        c->type = NULL;
                        c->val = j->exp;
                        c = c->next = emalloc(sizeof(struct tree_var_spec));
                        i = i->next;
                        j = j->next;
                    }
                    if(i->next || j->next)
                    {
                        fprintf(stderr, "Error: variable declaration number mis\
match on line %d\n", j->exp->lineno);
                        exit(1);
                    }
                    c->name = i->ident;
                    c->type = NULL;
                    c->val = j->exp;
                    c->next = NULL;
                    for(struct tree_idents *k = (i = $1)->next; k;
                        i = k, k = k->next)
                        free(i);
                    free(i);
                    for(struct tree_exps *k = (j = $3)->next; k;
                        j = k, k = k->next)
                        free(j);
                    free(j);
                }
        |       idents type '=' exps
                {
                    $$ = emalloc(sizeof(struct tree_var_spec));
                    struct tree_var_spec *c = $$;
                    struct tree_idents *i = $1;
                    struct tree_exps *j = $4;
                    while(i->next && j->next)
                    {
                        c->name = i->ident;
                        c->type = $2;
                        c->val = j->exp;
                        c = c->next = emalloc(sizeof(struct tree_var_spec));
                        i = i->next;
                        j = j->next;
                    }
                    if(i->next || j->next)
                    {
                        fprintf(stderr, "Error: variable declaration number mis\
match on line %d\n", j->exp->lineno);
                        exit(1);
                    }
                    c->name = i->ident;
                    c->type = $2;
                    c->val = j->exp;
                    c->next = NULL;
                    for(struct tree_idents *k = (i = $1)->next; k;
                        i = k, k = k->next)
                        free(i);
                    free(i);
                    for(struct tree_exps *k = (j = $4)->next; k;
                        j = k, k = k->next)
                        free(j);
                    free(j);
                }
        ;

idents:         TOK_IDENT
                {
                    $$ = emalloc(sizeof(struct tree_idents));
                    $$->ident = $1;
                    $$->next = NULL;
                }
        |       TOK_IDENT ',' idents
                {
                    $$ = emalloc(sizeof(struct tree_idents));
                    $$->ident = $1;
                    $$->next = $3;
                }
        ;

exps:           exp
                {
                    $$ = emalloc(sizeof(struct tree_exps));
                    $$->exp = $1;
                    $$->next = NULL;
                }
        |       exp ',' exps
                {
                    $$ = emalloc(sizeof(struct tree_exps));
                    $$->exp = $1;
                    $$->next = $3;
                }
        ;

type_decl:      TOK_TYPE TOK_IDENT type
                {
                    $$ = emalloc(sizeof(struct tree_decls));
                    $$->kind = tree_decls_kind_type_spec;
                    $$->type_spec.name = $2;
                    $$->type_spec.type = $3;
                }
        |       TOK_TYPE '(' type_specs ')'
                {
                    $$ = $3;
                }
        ;

type_specs:
                {
                    $$ = NULL;
                }
        |       TOK_IDENT type ';' type_specs
                {
                    $$ = emalloc(sizeof(struct tree_decls));
                    $$->kind = tree_decls_kind_type_spec;
                    $$->type_spec.name = $1;
                    $$->type_spec.type = $2;
                    $$->next = $4;
                }
        ;

type_decl_stmt: TOK_TYPE TOK_IDENT type
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_type_spec;
                    $$->stmt.type_spec.name = $2;
                    $$->stmt.type_spec.type = $3;
                }
        |       TOK_TYPE '(' type_specs_stmt ')'
                {
                    $$ = $3;
                }
        ;

type_specs_stmt:
                {
                    $$ = NULL;
                }
        |       TOK_IDENT type ';' type_specs_stmt
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_type_spec;
                    $$->stmt.type_spec.name = $1;
                    $$->stmt.type_spec.type = $2;
                    $$->next = $4;
                }
        ;

func_decl:      TOK_FUNC TOK_IDENT '(' params ')' type block
                {
                    $$ = emalloc(sizeof(struct tree_decls));
                    $$->kind = tree_decls_kind_func_decl;
                    $$->func_decl.name = $2;
                    $$->func_decl.params = $4;
                    $$->func_decl.type = $6;
                    $$->func_decl.body = $7;
                }
        |       TOK_FUNC TOK_IDENT '(' params ')' block
                {
                    $$ = emalloc(sizeof(struct tree_decls));
                    $$->kind = tree_decls_kind_func_decl;
                    $$->func_decl.name = $2;
                    $$->func_decl.params = $4;
                    $$->func_decl.type = NULL;
                    $$->func_decl.body = $6;
                }
        |       TOK_FUNC TOK_IDENT '(' ')' type block
                {
                    $$ = emalloc(sizeof(struct tree_decls));
                    $$->kind = tree_decls_kind_func_decl;
                    $$->func_decl.name = $2;
                    $$->func_decl.params = NULL;
                    $$->func_decl.type = $5;
                    $$->func_decl.body = $6;
                }
        |       TOK_FUNC TOK_IDENT '(' ')' block
                {
                    $$ = emalloc(sizeof(struct tree_decls));
                    $$->kind = tree_decls_kind_func_decl;
                    $$->func_decl.name = $2;
                    $$->func_decl.params = NULL;
                    $$->func_decl.type = NULL;
                    $$->func_decl.body = $5;
                }
        ;

block:           '{' stmts '}'
                {
                    $$ = $2;
                }
        ;

params:         idents type
                {
                    $$ = emalloc(sizeof(struct tree_vars));
                    struct tree_vars *c = $$;
                    struct tree_idents *i = $1;
                    while(i->next)
                    {
                        c->type = $2;
                        c->name = i->ident;
                        c = c->next = emalloc(sizeof(struct tree_vars));
                        i = i->next;
                    }
                    c->type = $2;
                    c->name = i->ident;
                    c->next = NULL;
                    for(struct tree_idents *j = (i = $1)->next; j;
                        i = j, j = j->next)
                        free(i);
                    free(i);
                }
        |       idents type ',' params
                {
                    $$ = emalloc(sizeof(struct tree_vars));
                    struct tree_vars *c = $$;
                    struct tree_idents *i = $1;
                    while(i->next)
                    {
                        c->type = $2;
                        c->name = i->ident;
                        c = c->next = emalloc(sizeof(struct tree_vars));
                        i = i->next;
                    }
                    c->type = $2;
                    c->name = i->ident;
                    c->next = $4;
                    for(struct tree_idents *j = (i = $1)->next; j;
                        i = j, j = j->next)
                        free(i);
                    free(i);
                }
        ;

type:           TOK_IDENT
                {
                    $$ = emalloc(sizeof(struct tree_type));
                    $$->kind = tree_type_kind_name;
                    $$->name = $1;
                }
        |       '[' ']' type
                {
                    $$ = emalloc(sizeof(struct tree_type));
                    $$->kind = tree_type_kind_slice;
                    $$->slice.type = $3;
                }
        |       '[' TOK_INT ']' type
                {
                    $$ = emalloc(sizeof(struct tree_type));
                    $$->kind = tree_type_kind_array;
                    $$->array.type = $4;
                    $$->array.len = $2;
                }
        |       TOK_STRUCT '{' field_decls '}'
                {
                    $$ = emalloc(sizeof(struct tree_type));
                    $$->kind = tree_type_kind_struct;
                    $$->structtype.fields = $3;
                }
        |       '(' type ')'
                {
                    $$ = $2;
                }
        ;

field_decls:
                {
                    $$ = NULL;
                }
        |       idents type ';' field_decls
                {
                    $$ = emalloc(sizeof(struct tree_vars));
                    struct tree_vars *c = $$;
                    struct tree_idents *i = $1;
                    while(i->next)
                    {
                        c->type = $2;
                        c->name = i->ident;
                        c = c->next = emalloc(sizeof(struct tree_vars));
                        i = i->next;
                    }
                    c->type = $2;
                    c->name = i->ident;
                    c->next = $4;
                    for(struct tree_idents *j = (i = $1)->next; j;
                        i = j, j = j->next)
                        free(i);
                    free(i);
                }
        ;

stmts:
                {
                    $$ = NULL;
                }
        |       stmt ';' stmts
                {
                    if($1)
                    {
                        struct tree_stmts *c = $$ = $1;
                        while(c->next)
                            c = c->next;
                        c->next = $3;
                    }
                    else
                        $$ = $3;
                }
        ;

stmt:           block
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.block = $1;
                    $$->stmt.lineno = yylineno;
                }
        |       simplestmt
                {
                    if($1)
                    {
                        $$ = emalloc(sizeof(struct tree_stmts));
                        $$->stmt = *$1;
                        free($1);
                        $$->stmt.lineno = yylineno;
                    }
                    else
                        $$ = NULL;
                }
        |       var_decl_stmt
                {
                    $$ = $1;
                    $$->stmt.lineno = yylineno;
                }
        |       type_decl_stmt
                {
                    $$ = $1;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_PRINT '(' exps ')'
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_print;
                    $$->stmt.exps = $3;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_PRINT '(' ')'
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_print;
                    $$->stmt.exps = NULL;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_PRINTLN '(' exps ')'
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_println;
                    $$->stmt.exps = $3;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_PRINTLN '(' ')'
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_println;
                    $$->stmt.exps = NULL;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_RETURN
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_return;
                    $$->stmt.exp = NULL;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_RETURN exp
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_return;
                    $$->stmt.exp = $2;
                    $$->stmt.lineno = yylineno;
                }
        |       ifstmt
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_if;
                    $$->stmt.ifstmt = $1;
                    $$->stmt.lineno = yylineno;
                }
        |       switchstmt
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_switch;
                    $$->stmt.switchstmt = $1;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_FOR block
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_for;
                    $$->stmt.forstmt.init = NULL;
                    $$->stmt.forstmt.condition = NULL;
                    $$->stmt.forstmt.iter = NULL;
                    $$->stmt.forstmt.body = $2;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_FOR exp block
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_for;
                    $$->stmt.forstmt.init = NULL;
                    $$->stmt.forstmt.condition = $2;
                    $$->stmt.forstmt.iter = NULL;
                    $$->stmt.forstmt.body = $3;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_FOR simplestmt ';' exp ';' simplestmt block
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_for;
                    $$->stmt.forstmt.init = $2;
                    $$->stmt.forstmt.condition = $4;
                    $$->stmt.forstmt.iter = $6;
                    $$->stmt.forstmt.body = $7;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_BREAK
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_break;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_CONTINUE
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_continue;
                    $$->stmt.lineno = yylineno;
                }
        |       TOK_FALLTHROUGH
                {
                    $$ = emalloc(sizeof(struct tree_stmts));
                    $$->stmt.kind = tree_stmt_kind_fallthrough;
                    $$->stmt.lineno = yylineno;
                }
        ;

simplestmt:
                {
                    $$ = NULL;
                }
        |       exp
                {
                    $$ = emalloc(sizeof(struct tree_stmt));
                    $$->kind = tree_stmt_kind_exp;
                    $$->expstmt = *$1;
                    free($1);
                }
        |       assignment
                {
                    $$ = emalloc(sizeof(struct tree_stmt));
                    $$->kind = tree_stmt_kind_assign;
                    $$->assign = $1;
                }
        |       op_assignment
                {
                    $$ = emalloc(sizeof(struct tree_stmt));
                    $$->kind = tree_stmt_kind_assignop;
                    $$->assignop = $1;
                }
        |       idents TOK_ASSIGN exps
                {
                    $$ = emalloc(sizeof(struct tree_stmt));
                    $$->kind = tree_stmt_kind_shortdecl;
                    $$->shortdecl.idents = $1;
                    $$->shortdecl.exps = $3;
                }
        |       exp TOK_INC
                {
                    $$ = emalloc(sizeof(struct tree_stmt));
                    $$->kind = tree_stmt_kind_inc;
                    $$->exp = $1;
                }
        |       exp TOK_DEC
                {
                    $$ = emalloc(sizeof(struct tree_stmt));
                    $$->kind = tree_stmt_kind_dec;
                    $$->exp = $1;
                }
        ;

assignment:     exps '=' exps
                {
                    $$.left = $1;
                    $$.right = $3;
                }
        ;

op_assignment:  exp TOK_PLUSEQ exp
                {
                    $$.kind = tree_assignop_kind_plus;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_MINUSEQ exp
                {
                    $$.kind = tree_assignop_kind_minus;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_OREQ exp
                {
                    $$.kind = tree_assignop_kind_or;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_XOREQ exp
                {
                    $$.kind = tree_assignop_kind_xor;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_TIMESEQ exp
                {
                    $$.kind = tree_assignop_kind_times;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_DIVEQ exp
                {
                    $$.kind = tree_assignop_kind_div;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_REMEQ exp
                {
                    $$.kind = tree_assignop_kind_rem;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_LSHIFTEQ exp
                {
                    $$.kind = tree_assignop_kind_lshift;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_RSHIFTEQ exp
                {
                    $$.kind = tree_assignop_kind_rshift;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_ANDEQ exp
                {
                    $$.kind = tree_assignop_kind_and;
                    $$.left = $1;
                    $$.right = $3;
                }
        |       exp TOK_ANDNOTEQ exp
                {
                    $$.kind = tree_assignop_kind_andnot;
                    $$.left = $1;
                    $$.right = $3;
                }
        ;

ifstmt:         TOK_IF exp block
                {
                    $$.init = NULL;
                    $$.condition = $2;
                    $$.body = $3;
                    $$.elsebody = NULL;
                }
        |       TOK_IF exp block TOK_ELSE ifstmt
                {
                    $$.init = NULL;
                    $$.condition = $2;
                    $$.body = $3;
                    $$.elsebody = emalloc(sizeof(struct tree_stmts));
                    $$.elsebody->stmt.kind = tree_stmt_kind_if;
                    $$.elsebody->stmt.ifstmt = $5;
                    $$.elsebody->next = NULL;
                }
        |       TOK_IF exp block TOK_ELSE block
                {
                    $$.init = NULL;
                    $$.condition = $2;
                    $$.body = $3;
                    $$.elsebody = $5;
                }
        |       TOK_IF simplestmt ';' exp block
                {
                    $$.init = $2;
                    $$.condition = $4;
                    $$.body = $5;
                    $$.elsebody = NULL;
                }
        |       TOK_IF simplestmt ';' exp block TOK_ELSE ifstmt
                {
                    $$.init = $2;
                    $$.condition = $4;
                    $$.body = $5;
                    $$.elsebody = emalloc(sizeof(struct tree_stmts));
                    $$.elsebody->stmt.kind = tree_stmt_kind_if;
                    $$.elsebody->stmt.ifstmt = $7;
                    $$.elsebody->next = NULL;
                }
        |       TOK_IF simplestmt ';' exp block TOK_ELSE block
                {
                    $$.init = $2;
                    $$.condition = $4;
                    $$.body = $5;
                    $$.elsebody = $7;
                }
        ;

switchstmt:     TOK_SWITCH '{' cases '}'
                {
                    $$.init = NULL;
                    $$.exp = NULL;
                    $$.cases = $3;
                }
        |       TOK_SWITCH simplestmt ';' '{' cases '}'
                {
                    $$.init = $2;
                    $$.exp = NULL;
                    $$.cases = $5;
                }
        |       TOK_SWITCH exp '{' cases '}'
                {
                    $$.init = NULL;
                    $$.exp = $2;
                    $$.cases = $4;
                }
        |       TOK_SWITCH simplestmt ';' exp '{' cases '}'
                {
                    $$.init = $2;
                    $$.exp = $4;
                    $$.cases = $6;
                }
        ;

cases:
                {
                    $$ = NULL;
                }
        |       TOK_CASE exps ':' stmts cases
                {
                    $$ = emalloc(sizeof(struct tree_cases));
                    $$->val = $2;
                    $$->body = $4;
                    $$->next = $5;
                }
        |       TOK_DEFAULT ':' stmts cases
                {
                    $$ = emalloc(sizeof(struct tree_cases));
                    $$->val = NULL;
                    $$->body = $3;
                    $$->next = $4;
                }
        ;

exp:            '(' exp ')'
                {
                    $$ = $2;
                    $$->lineno = yylineno;
                }
        |       TOK_IDENT
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_ident;
                    $$->ident = $1;
                    $$->lineno = yylineno;
                }
        |       TOK_INT
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_int;
                    $$->intval = $1;
                    $$->lineno = yylineno;
                }
        |       TOK_FLOAT
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_float;
                    $$->floatval = $1;
                    $$->lineno = yylineno;
                }
        |       TOK_RUNE
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_rune;
                    $$->runeval = $1;
                    $$->lineno = yylineno;
                }
        |       TOK_STR
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_str;
                    $$->strval = $1;
                    $$->lineno = yylineno;
                }
        |       '+' exp %prec UNARY
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_unary;
                    $$->unary.kind = tree_unaryexp_kind_plus;
                    $$->unary.right = $2;
                    $$->lineno = yylineno;
                }
        |       '-' exp %prec UNARY
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_unary;
                    $$->unary.kind = tree_unaryexp_kind_minus;
                    $$->unary.right = $2;
                    $$->lineno = yylineno;
                }
        |       '!' exp %prec UNARY
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_unary;
                    $$->unary.kind = tree_unaryexp_kind_not;
                    $$->unary.right = $2;
                    $$->lineno = yylineno;
                }
        |       '^' exp %prec UNARY
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_unary;
                    $$->unary.kind = tree_unaryexp_kind_comp;
                    $$->unary.right = $2;
                    $$->lineno = yylineno;
                }
        |       exp TOK_OR exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_or;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp TOK_AND exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_and;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp TOK_EQ exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_eq;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp TOK_NEQ exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_neq;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '<' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_lt;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp TOK_LEQ exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_leq;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '>' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_gt;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp TOK_GEQ exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_geq;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '+' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_plus;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '-' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_minus;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '|' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_bitor;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '^' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_xor;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '*' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_times;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '/' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_div;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '%' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_rem;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp TOK_LSHIFT exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_lshift;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp TOK_RSHIFT exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_rshift;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '&' exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_bitand;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp TOK_ANDNOT exp
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_binary;
                    $$->binary.kind = tree_binaryexp_kind_andnot;
                    $$->binary.left = $1;
                    $$->binary.right = $3;
                    $$->lineno = yylineno;
                }
        |       exp '(' ')'
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_call;
                    $$->call.func = $1;
                    $$->call.exps = NULL;
                    $$->lineno = yylineno;
                }
        |       exp '(' exps ')'
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_call;
                    $$->call.func = $1;
                    $$->call.exps = $3;
                    $$->lineno = yylineno;
                }
        |       exp '[' exp ']'
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_index;
                    $$->index.arr = $1;
                    $$->index.index = $3;
                    $$->lineno = yylineno;
                }
        |       exp '.' TOK_IDENT
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_field;
                    $$->field.instance = $1;
                    $$->field.field = $3;
                    $$->lineno = yylineno;
                }
        |       TOK_APPEND '(' exp ',' exp ')'
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_append;
                    $$->append.exp1 = $3;
                    $$->append.exp2 = $5;
                    $$->lineno = yylineno;
                }
        |       TOK_LEN '(' exp ')'
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_len;
                    $$->exp = $3;
                    $$->lineno = yylineno;
                }
        |       TOK_CAP '(' exp ')'
                {
                    $$ = emalloc(sizeof(struct tree_exp));
                    $$->kind = tree_exp_kind_cap;
                    $$->exp = $3;
                    $$->lineno = yylineno;
                }
        ;
